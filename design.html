<html><head>
  <meta charset="utf-8">
  <meta name="description" content="Introduction to database design.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="database, design, model, structure, normalization, performance, concept, physical, diagram">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>DB Design</title>  

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">  
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="../prism.css">
  <script src="../prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body>

<div class="container">
        
<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>  
    <div class="col  bottom-right">
        <a href="../engineering.html">index</a>&lt;--
    </div>
</div><hr>


<h2>Database Design</h2>

<div class="alert alert-secondary shadow-sm">
When a designer start a new project it can start with the user interface (UI) or with Database Design (DB). 
Most of the time this is done using a <em>design document</em> that describe the database. 
After the document is approved a developement team build the scripts to implement the database,
and the applications arround it.
</div>

<h2>Requirements</h2>

<p>If you work in a traditional software company probably you will have a team. Depending how the project is organized (scrum, agile or canban) you may be asked to create requirements and presentations for the project.</p>

<p>If the project use large amount of data requirements will include a database and will make recommendations about the database structure but will not go in much details. Sometimes requirements will include a "Conceptual Model" (CM).</p>

<h2>Database Models</h2>

<p>A database model is a graphical representation of database elements. 
This is used by database designers to communicate high level design of database structure.  
There are 3 model types you can make before you implement a large database. 
You need to understend how to read these models if you wish to create a large project.
</p>

<ul>
<li>Conceptual Model</li>
<li>Logical Model</li>
<li>Phisical Model</li>
</ul>

<p>Each model has its own merits but the most valuable is the <em>Conceptual Model</em>.
This is the only model that I will show in details how to make using entry level tools.
</p>


<h2>Drawing Tools</h2>

<p>Most database designers are using tools to create a database model diagrams. These tool are based on IBM UML notation: (Unified Modeling Language) and can connect to existing databases. You can use them to generate code for you. 
However some companies that are less traditional and more efficient are using paper and pencil for design.</p>

<p>On-line tools are implemented as SaaS (Softare as a Service) platform. 
Yes there are websites that enable you to design on-line for a small price.
One of these is <em>DB Designer</em>. 
Honestly I have no intention to use this tool for my open source projects.
It can not export your diagram as SVG so I will pass thank you.
</p>

<h2>Conceptual Symbols</h2>

<p>To represent an entity use a rectangle. To represent relations use a line. If you wish to represent the relation cardinality, use a conceptual notation for the line end. This consist of a bar, a circle or a crow foot like in the picture below:</p>

<div align="center">
  <img src="img/Symbols.svg" alt="Symbols.svg"
  width="480" class="img-fluid protect rounded shadow border" >    
  <p>Conceptual Symbols</p>
</div>  

<div class="alert alert-warning"><b>Inovation: </b>
These symbols are difficult to draw without proper design tools.
To improve design productivity we suggest a new notation.
Next we will present a new set of simbols used in our diagrams.
</div>


<h2>Sage Symbols</h2>

<p>The value of a good conceptual model is very high. One picture can value as 1000 words.
However the most advanced the tools you use the more money you spend.
The most simple tool you can use is: Microsoft paint. 
It is not very professional to use Paint becouse it is producing raster type of images: (jpg/png). 
</p>

<p>
A second tool I found useful is Google Drawings. 
With this tool you can create workflow diagrams and export them as SVG.
As you know, SVG is a vector format of higher quality for Internet pages.
We have selected for Sage-Code diagrams a set of symbols similar to the official ones.
These symbols will be used in our diagrams to make efficient SVG based models.
</p>

<div align="center">
  <img src="img/Model.svg" alt="Model.svg"
  width="520" class="img-fluid protect rounded shadow border" >    
  <p>Sage Symbols</p>
</div>  

<h2>Normalization</h2>

<p>One of the most strong principles in relational database design is the principle of normalization. This is the process of organizing data in a database. There are two goals of the normalization process:</p>
<ol>
<li>eliminating redundant data</li>
<li>ensuring  comprehensive dependencies</li>
</ol>
<p><b>Edgar Codd</b> is the inventor of the relational model (RM). He has introduced the concept of normalization and what we now know as the First normal form (1NF) in 1970. Codd went on to define the Second normal form (2NF) and Third normal form (3NF) in 1971</p>

<p><b>References to Wikipedia</b></p>

<p>The normalization process is using several normalization rules:</p>
<ul>
<li><a title="First normal form" href="https://en.wikipedia.org/wiki/First_normal_form"
       target="_blank" rel="nofollow noreferrer noopener">1NF - First Normal Form</a></li>
<li><a title="Second normal form" href="https://en.wikipedia.org/wiki/Second_normal_form"
       target="_blank" rel="nofollow noreferrer noopener">2NF - Second Normal Form</a></li>
<li><a title="Third normal form" href="https://en.wikipedia.org/wiki/Third_normal_form"
       target="_blank" rel="nofollow noreferrer noopener" >3NF - Third Normal Form</a></li>
<li><a title="Elementary Key Normal Form" href="https://en.wikipedia.org/wiki/Elementary_Key_Normal_Form"
       target="_blank" rel="nofollow noreferrer noopener">EKNF - Elementary Key Normal Form</a></li>
<li><a title="Boyce-Codd normal form" href="https://en.wikipedia.org/wiki/Boyce%E2%80%93Codd_normal_form"
       target="_blank" rel="nofollow noreferrer noopener">BCNF - Boyce-Codd Normal Form</a></li>
<li><a title="Fourth normal form" href="https://en.wikipedia.org/wiki/Fourth_normal_form"
       target="_blank" rel="nofollow noreferrer noopener">4NF - Fourth Normal Form</a></li>
<li><a class="external text" href="http://researcher.watson.ibm.com/researcher/files/us-fagin/icdt12.pdf"
       target="_blank" rel="nofollow noreferrer noopener">ETNF - Essential Tuple Normal Form</a></li>
<li><a title="Fifth normal form" href="https://en.wikipedia.org/wiki/Fifth_normal_form"
       target="_blank" rel="nofollow noreferrer noopener">5NF - Fifth Normal Form</a></li>
<li><a title="Sixth normal form" href="https://en.wikipedia.org/wiki/Sixth_normal_form"
       target="_blank" rel="nofollow noreferrer noopener">6NF - Sixth Normal Form</a></li>
<li><a title="Domain/key normal form" href="https://en.wikipedia.org/wiki/Domain/key_normal_form"
       target="_blank" rel="nofollow noreferrer noopener">DKNF - Domain/Key Normal Form</a></li>
</ul>
<p><b>First normal form</b> (<b>1NF</b>): This is a property of a relation in a relational database. A relation is in first normal form if and only if the domain of each attribute contains only atomic indivisible values, and the value of each attribute contains only a single value from that domain.</p>
<p>First normal form enforces these criteria:</p>
<ul>
<li>Eliminate repeating groups in individual tables;</li>
<li>Create a separate table for each set of related data;</li>
<li>Identify each set of related data with a primary key.</li>
</ul>
<p><b>Second normal form (2NF):</b> A table that is in first normal form (1NF) must meet additional criteria for second normal form. Specifically: a table is in 2NF if it is in 1NF and no non-prime attribute is dependent on any proper subset of any candidate key of the table.</p>
<p><b>A non-prime attribute of a table</b> is an attribute that is not a part of any candidate key of the table. Atrbutes that are part of a candidate kye are called prime attributes.</p>
<p><b>Third normal form</b> <b>(3NF)</b>: is a normal form that is used in normalizing a database design to reduce the duplication of data and ensure referential integrity by ensuring that:</p>
<p>1. the entity is in second normal form</p>
<p>2. all the attributes in a table are determined only by the candidate keys of that table and not by any non-prime attributes.</p>
<ul>
<li>3NF was designed to improve database processing while minimizing storage costs.</li>
<li>3NF data modeling was ideal for online transaction processing (OLTP) applications with heavy order entry type of needs.</li>
</ul>
<p>Most of applications use Third Normal Form (3NF).</p>
<p>These principles are very scientific and difficult to understand.  However a good designer must know how to apply these principles. This comes within experience, with many try and errors.</p>
<div class="alert alert-danger"><b>Denormalization:</b> Highly normalized databases are not always the best choice. 
Having data spread over many tables require joining them back together to make comprehensive SQL.
Sometimes you have to de-normalize a table to improve query performance.</div>

<h2>Conceptual Models</h2>

<p>In Relational Algebra the concepts are Logical or Abstract. 
In a Relational database, we implement the Logical or Conceptual model using Tables.
So here are some example of conceptual diagrams patterns that you can use do make a database model:</p>

<hr>

<div align="center">
  <img src="img/Relation11.svg" alt="1:1 Relations"
  width="480" class="img-fluid protect rounded shadow border" >    
  <p>1:1 Relations</p>
</div> 

<div class="alert alert-info"><span style="color:brown">Note: </span>The most simple relation is 1:1. 
That is for one record in main entity table we have one record into related table.
This relation can have variations when the relation key is optional (can be null).
We call 1:1 a <em>strong</em> relation and 0:0 relation a <em>week</em> relation.
</div>

<hr>

<div align="center">
  <img src="img/Relation1M.svg" alt="1:M Relations"
  width="480" class="img-fluid protect rounded shadow border" >    
  <p>1:M Relations</p>
</div> 

<div class="alert alert-info"><span style="color:brown">Note: </span>The most common relation is 1:M. 
That is for one record in master entity we have zero, one or more records in a detail table.
We enforce the cardinality between master and detail table by making mandatory or optional keys.
Also some relations require to use triggers that verify the relation when we add or remove records.
</div>

<hr>

<div align="center">
  <img src="img/Association.svg" alt="Association"
  width="480" class="img-fluid protect rounded shadow border" >    
  <p>Association</p>
</div> 

<div class="alert alert-info"><span style="color:brown">Note: </span>The relation M:M can not exist in a relational database. 
We need to create an associate third table that is containing foreign keys from both other tables.
This table can have a surogate ID or it can use both foreign keys to create a composite primary key.
</div>


<hr>

<div align="center">
  <img src="img/Inheritance.svg" alt="Inheritance"
  width="480" class="img-fluid protect rounded shadow border" >    
  <p>Inheritance</p>
</div> 

<div class="alert alert-info"><span style="color:brown">Note: </span>The inheritance is a complex relation
that is very simmilar to M:M relation, except that we may have multipe detail tables.
Between the detail tables there is an exclusivity constraint.
This constraint allows only one of detail entity to have associated main record.
If this constraint do not exist, the Inheritance is not pure.
</div>

<hr>

<div align="center">
  <img src="img/Extension.svg" alt="Extension"
  width="480" class="img-fluid protect rounded shadow border" >    
  <p>Extension</p>
</div> 

<div class="alert alert-info"><span style="color:brown">Note: </span>The extension model is very curious. 
It is similar to Inheritance, except there are no exclusive constraints.
This is called Extension but in fact is a non-pure Inheritance.
Modern databases enable you to store objects. This may improve your way of implementing Inheritance.
</div>

<h2>Detail Design</h2>

<div class="alert alert-secondary">A database design must contain complete and precise information about all database objects. This is necesary for software developement team to be able to create DDL scripts for making the database structure for a data centric application.</div>

<h4>Content</h4>

<ul>
<li>ER Diagrams</li>
<li>List of tables</li>
<li>List of constraints for each table</li>
<li>List of triggers</li>
<li>List of indexes</li>
<li>List of views</li>
<li>Metadata</li>
</ul>

<p><b>Note:&nbsp;</b>Detail design of database do not contain description of stored procedures. This design is too complex to be included in database design document. So most Architects let the developement team to decide what packages to implement.</p>

<h4>Scripts</h4>

<p>For implementing a database, developers will create DDL scripts. This is a subset of SQL that means: "Data Definition Language". This language enable creation and modification of objects in a database.</p>

<p>The order of scripts is very important. You can not create indexes for a table that do not exist. So here is the natural order of making objects in a database. First you make all the tables with primary keys and check constraints. Second you make the indexes. Third you make the foreign key costraints.<>

<h4>Indexes</h4>

<div class="alert alert-warning"><span style="color:DarkRed">Warning:&nbsp;</span>A database with no indexes is slow. You need to design every index with a purpose. Too many indexes can slow down a database. There are rules to help you design the indexes.</div>

<ul>
<li>Primary key must have an associated unique index.</li>
<li>Alternate keys must have an associated unique indexes.</li>
<li>Foreign keys must have associated indexes that are not unique.</li>
<li>Frequent filtered fields with many values must have non unique indexes</li>
<li>Frequent filtered fields with few values must have bitmap index</li>
<li>Assiciative tables may be index organized tables</li>
</ul>

<h4>Storage</h4>

<div class="alert alert-warning"><span style="color:DarkRed">Warning:&nbsp;</span>Storage specification can be part of detailed design document. If this is missing, database administrator will have no choise but to enable default database storage. This may be not good enaugh for critical performance applications.</div>

<ul>
<li>Metadata should be stored on small but very fast devices (SSD)</li>
<li>Critical data must be stored on redundant storage. (Mirror, RAID10)</li>
<li>Non critical data can be stored on non redundant storage. (RAID0)</li>
</ul>

<h4>Density</h4>

<div class="alert alert-warning"><span style="color:DarkRed">Warning:&nbsp;</span>Ignorance is the seed of desasters. A good database architect must pay attention to data density and update frequency. A compact table is harder to update and can quicly loose performance. A sparsed table can become too large and therefore slower than should be.</div>
<ul>
<li>Tables that are often updated will enable 10-30% provision for every data block.</li>
<li>Metadata tables that are infrequent updated should have maximum 5% free block space.</li>
</ul>

<p><b>Security:&nbsp;</b>Critical databases must have good design for data access rules. This is done using a special script that is using DCL (Data Control Language). You will learn this language in our Programming Language tutorial for SQL.</p>

<p><b>Maintenance:&nbsp;</b>Database administrator will peform no optimizations if this is not required by software developement team or database architect. Therefore a good design document should include directives for database maintenance tasks, like frequency fo index rebuid, and frequency for compacting and reorganization of table data to reset the free space.</p>

<h2>Design Example</h2>

<div class="alert alert-secondary">Next we present an example of a simple database model for Agile methodology. Let's consider a project management tool for a company that uses <em>Agile Methodology</em> to manage projects. First we need to know how Agile methodology works. Then we design a conceptual model for representing the data. We will show you how to create the Logical and the Conceptual models.</div>

<h3>Agile Rules:</h3>

<p>In an agile company one team is assigned a single project. A project consist of several epics and each epic is represented by several stories. One story may have several tasks to be completed. A developer can work in a single team and can be assigned to resolve multiple stories. A story need a resolver, so when we create a story it must be assigned immediatly, otherwise we can not create stories. </p>

<div align="center">
  <img src="img/Agile.svg" alt="Agile"
  width="480" class="img-fluid protect rounded shadow border" >    
  <p>Logic Model</p>
</div> 

<div class="alert alert-info">Logic model shows two main entity tables {PROJECT, DEVELOPER}, two secondary entities {EPIC, TASK} and 2 associative tables {TEAM, STORY}. Between the entities we draw references by following Agile rules. For a better understanding of relations we have given some names.</div>

<h3>Other Rules:</h3>
<ul>
<li>An epic has a business value from 0 to 10;</li>
<li>A story has a Fibonacci number: 1,2,3,5,8,13;</li>
<li>A story has to be resolved into one sprint;</li>
</ul>

<div class="alert alert-warning"><span style="color:brown">Advice:</span>
If possible do not cross references one over the other. 
This will clutter the diagram and make it difficult to read.
On a complex database not all entities and relation need to be present in a single diagram.
</div>

<h3>Table Design</h3>
<p>At first we design tables with <em>primary key</em> and foreign keys.
This is the <em>high level design</em> of database table.
Tables may have additional attributes that will be part of <em>Phisical Model.</em>
</p>

<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Table Type</th>
<th>Name</th>
<th>Primary Key</th>
<th>Foreign Keys</th>
</tr>
</thead>
<tbody>
<tr>
<td>Entity</td>
<td>PROJECT</td>
<td>ID</td>
<td>OWNER_ID</td>
</tr>
<tr>
<td>Entity</td>
<td>DEVELOPER</td>
<td>ID</td>
<td>PROJECT_ID</td>
</tr>
<tr>
<td>Association</td>
<td>TEAM</td>
<td>ID</td>
<td>MASTER_ID</td>
</tr>
<tr>
<td>Detail</td>
<td>EPIC</td>
<td>ID</td>
<td>PROJECT_ID</td>
</tr>
<tr>
<td rowspan="2">Association</td>
<td rowspan="2">STORY</td>
<td rowspan="2">ID</td>
<td>EPIC_ID </td>
</tr>
<tr>
<td>REZOLVER_ID</td>
</tr>
<tr>
<td rowspan="2">Detail</td>
<td rowspan="2">TASK</td>
<td rowspan="2">ID</td>
<td>STORY_ID</td>
</tr>
<tr>
<td>REVIEWER_ID</td>
</tr>
</tbody>
</table>

<h3>Relations:</h3>
<ol>
<li>One project has one project owner: Relation 1:1</li>
<li>One project has at least one epic: Relation 1:M</li>
<li>One epic has one or many stories: Relation 1:0-M</li>
<li>Each developer is member into a single team: Relation 1:M</li>
<li>One team is assigned to a single project: Relation 1:1</li>
<li>One story must be assigned to a developer: Relation 1:0-M.</li>
<li>One story has several tasks: Relation 1:0-M.</li>
<li>One story has optional a reviewer: Relation 0-1:0-M.</li>
</ol>

<p>These relations are implementing several fundamental Agile rules. For some of the rules we need to implement triggers and attribute constraints. This can be done in the phisical model. We do not show you the phisical model in this article.</p>

<h3>ER Diagram</h3>

<p>ER diagram is used to show attributes, primary keys and foreign keys. This is also called <em>physical model</em>. This diagram is used by developers to create the <em>database structure</em>. Also can be used by developers who use the database to create SQL queries for applications.<br /></p>

<div align="center">
  <img src="img/ER-Diagram.svg" alt="ER-Diagram"
  width="1000" class="img-fluid protect rounded shadow border" >    
  <p>ER-Diagram</p>
</div> 

<div class="alert alert-warning"><span style="color:brown">Note:</span>
I have used <a href="https://app.diagrams.net/">drawio app</a> to make this diagram. A good diagram can bust morale in your team and help you avoid many defects. For better productivity I advice you to use better DB tools. There are tools that can generate SQL scripts from diagrams.
</div>

<h3>Conclusion:</h3>
<p>This has demonstrate how to make a data model to resolve a real problem.
We have shown the Logical Model, and the Phisical Model.
Using these models you can understend the design of a database.
Having a model will help you build better SQL to analyze your data.
</p>

<hr>

<p><b>Read next:</b>
<a href="systems.html">Operating Systems</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>


</div>


</body>
</html>