<html><head>
  <meta charset="utf-8">
  <meta name="description" content="Fundamental concepts of computer programming.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="programming, concepts, logic expressions">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>SC Concepts</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="../prism.css">
  <script src="../prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body>

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="../engineering.html">index</a>&lt;--
    </div>
</div><hr>

<h1>Programming Concepts</h1>

<div class="alert alert-secondary shadow-sm">
This article is designed for beginners in computer science. We start with basic concepts used in computer science. All programming languages are based on these concepts. Some of these are used to make new software and some others  for resolving problems or running a business.</div>

<h2>Video Lecture</h2>

<p>If you have time and bandwidth you can watch next video to learn most basic concepts of computer programming. This video is about 35 minutes long, and is very informative for beginners. It was filmed in Chicago by Elucian in Aug, 3, 2016.  Please press thumb up button if you like it. Thanks!
</p>

<div align="center">
    <a href="https://www.youtube.com/watch?v=8SeoMw2B1Ps"
    target="_blank" rel="nofollow noopener noreferrer">
    <img src="../images/youtube.svg" width="200" alt="Programming Concepts"/></a>
</div>

<h4>Bookmarks:</h4>

<ul>
<li><a href="#programs">Computer programs</a></li>
<li><a href="#symbols">Programming symbols</a></li>
<li><a href="#identifiers">Identifiers</a></li>
<li><a href="#types">Type systems</a></li>
<li><a href="#literals">Data literals</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#languages">Programming languages</a></li>
<li><a href="#paradigms">Programming paradigms</a></li>
<li><a href="#logic">Logic science</a></li>
<li><a href="#machines">State Machines</a></li>
<li><a href="#inteligence">Artificial Intelligence</a></li>
</ul>

<hr>

<h2><a id="programs">Computer programs</h2>

<div class="alert alert-secondary shadow-sm">Computer programs are step by step instructions that a computer can execute. These are grouped in statements that are stored into a modules or package. A program can have many packages. Sometimes programs are also called applications.</div>

<p>Computer programs consist of files, stored in folders. We call this a "project" or "code base". A project contains text files having language specific extension, data files and perhaps images, audio and video files. Usually one file is the main file that uses the other files. A project should contain also documentation files.</p>

<p>Program execution will resolve a problem and communicate the result or will have a physical effect: for example printing a message to the computer monitor or moving the arm of a robot. A program can be executed one or multiple times.</p>


<h3>Sub-programs</h3>

<div class="alert alert-secondary shadow-sm">Sub-programs have the role: "separation of concerns". It means one sub-program does only one small thing. The main program combine the effects of multiple sub-programs to implement the end-to-end functionality of the system. Sub-programs are contained in programs or delivered as components or libraries to be re-used in many applications.</div>

<p>Depending on the computer language sub-programs are called: sub-routines, procedures, functions, methods or rules. Common is that all encapsulate a specific functionality. The main program is orchestrating the execution of sub-programs by transferring the execution main process into sub-processes that can be executed synchronously or asynchronously (sometimes in parallel).</p>

<h3>Parameters and results</h3>

<div class="alert alert-secondary shadow-sm">Sub-routines can receive parameters and can compute results. Sometimes we call these "formal parameters" or "receiver variables". Usually parameters for sub-routines are immutable during sub-routine execution. The result can be collected by the main program and used in next computations. Depending on the programming language the syntax of parameters and subroutine call can be different.</div>

<p>Parameters are similar to local variables. They are known only inside the sub-routine. Once the subroutine is finished, the value of the parameters is lost or can be propagated back to the caller. This depends on the declaration syntax and purpose of the parameter.</p>

<h3>Arguments and values</h3>

<div class="alert alert-secondary shadow-sm">Subprograms must receive values that are assigned to parameters. These values are  called "actual parameters" or "arguments". Important thing is that values of parameters can be: constants/expressions or variables.</div>

<p>If an argument is a constant, you may be able to modify them inside sub-program but this has no effect over the argument. The argument remain constant. If an argument is a variable, then you have a choice to propagate changes back to caller or to protect the parameters against this secondary effect.</p>

<p>Output parameters are parameters that can propagate back the modified values outside of sub-program. This is a feature many languages have. It may be implemented using "pointers" or "references". For each computer language you have to learn how to use input/output parameters.</p>

<h3>Variable number of arguments</h3>

<div class="alert alert-secondary shadow-sm">Lately, most languages can support a variable number of arguments using a special prefix for a parameter that accept multiple values. This symbol can be "*" or "...", depending on the language.</div>
<p>When you make a sub-routine call, you can use many arguments separated by comma that will be grouped to into a collection and sent to the sub-routine. Then you can access these parameters by index and use each value.</p>
<p>Sometimes, parameters are optional. In this case, the call can also have a variable number of arguments but the arguments that are optional must be specified by name. You will understand these concepts better if we use an example:</p>

<h4>Example:</h4>

<pre><code class="language-python">#last parameter is optional
def add(a, b, c = 0, *d):
    return a+b+c+sum(d)
print( add(1,2) ) # 3
print( add(1,2,3) ) # 6
print( add(1,2,c = 3) ) # 6
print( add(1,2,3, 4, 5) )# 15</code></pre>

<h3>Namespaces and scope</h3>

<div class="alert alert-secondary shadow-sm">Each sub-program usually has its own "local scope". Sometimes in the local scope you can define nested sub-programs. Most languages will enable creation of variables and constants in local scope.</div>

<p>When you define identifiers you must know where this identifier is visible. If an identifier is visible in all your program, it is called "global" identifier. The area of visibility is called "scope". For example a program can have a single "global scope".</p>

<h3>Shadowing Effect</h3>

<p>Shadowing is a secondary effect of most programming languages that support local scope. If you define a variable in local scope having the same name as a variable defined in outer scope the two names will collide. To avoid collision, the languages usually hide the external variable and enable access only to local variable. This effect is called "shadowing". Parameters also have a shadowing effect over outer variables or parameters.</p>


<h3>Dot notation</h3>
<p>When you define a data structure, the elements in data structure can be public or private. If elements are public, usual notation called "dot notation", enable you to access a member of a collection by name.</p>
<h4>Example:</h4>
<div>
<pre><pre><code class="language-python">class Person:
    name = "Barbu"
    age = 22
pass #end class
# using dot notation
print(Person.name) # Barbu
print(Person.age) # 22</code></pre>
</div>
<p><b>Note:</b>&nbsp;In previous example we define a "structure class" in Python that is also known as "data class"</p>

<div>

<h2><a id="symbols"/>Programming Symbols</h2>

<p>A program is made of symbols that are used to create expressions. Most languages are using expressions that are similar to the ones we learn in mathematics. Sometimes beginners have hard time understanding the difference between "expressions", "symbols" and relation with "functions". We will explain these things here.</p>

<p>Symbols can be single character or multi-character. Single character symbols can be {"digits", "letters", "ASCII", "UNICODE"}. We use symbols to create: operators, punctuation marks, numeric literals, string literals, identifiers, enumerations and data collections.</p>

<p>In general a program manipulate "data". This is also made of symbols. We learn in school to count using Arabic digital symbols: 0,1,2,3,4,5,6,7,8,9. We also learn how to read and write text using Latin alphabet: Aa, Bb, Cc, Dd, Ee, Ff, Gg ... Zz. This is not the case in all cultures around the globe. Some cultures are using other symbols to represent data.</p>

<h4>Encoding</h4>

<p>The way we represent data using the symbols is called <em>encoding</em>. The most popular encoding system known as Unicode. Before Unicode was invented we used different encodings system known as: ASCII. For different countries there is an Extended ASCII table that has diacritics and special characters. Also Unicode have several variations: UTF16, UTF32 and UTF8.</p>

<h4>Binary</h4>

<p>Computer is using binary representations of "1" and "0" for encoding symbols. The "1" is usually a positive electrical charge while "0" represents no charge. It is similar to a light bulb. When light is on we can consider it logic = "1". When lights is off we consider logic="0&Prime;.</p>

<h4>Storage</h4>

<p>Electronic devices can store data using specialized devices to store data. There are several physical methods: "electro-static", "electro-magnetic", "optic" or "magneto-optic" and of course "solid state - electronics". The point is, all computation is digital, and is based on a binary system.</p>

<h2><a id = "#numeric"/>Numeric Systems</h2>

<p>A numeric system is a way of representing numbers. In computer science a number can be represented by different systems and you have to learn this in order to understand code and be able to produce new code.</p>

<h3>Decimal System</h3>

<p>You learn in school Arithmetic using decimal system. This is based on old Arabic symbols now considered the best numeric representation. It uses one single symbol for each digit except 10 that is using two symbols. </p>

<h4>Digit Names</h4>

<p>We have a "name" for each digit. Funny though, numbers are translated different in different languages.</p>

<table class="table table-sm table-bordered">
<tr>
    <th>Decimal</th>
    <th>English</th>
    <th>Romanian</th>
    <th>Italian</th>
    <th>Spanish</th>
    <th>French</th>
</tr>
<tr><th>0 <td>zero </th><td>zero </td><td>zero   </td><td>cero  </td><td>zéro  </td></tr>
<tr><th>1 <td>one  </th><td>unu  </td><td>uno    </td><td>uno   </td><td>une   </td></tr>
<tr><th>2 <td>two  </th><td>doi  </td><td>due    </td><td>dos   </td><td>deux  </td></tr>
<tr><th>3 <td>three</th><td>trei </td><td>tre    </td><td>Tres  </td><td>trois </td></tr>
<tr><th>4 <td>four </th><td>patru</td><td>quattro</td><td>cuatro</td><td>quatre</td></tr>
<tr><th>5 <td>five </th><td>cinci</td><td>cinque </td><td>cinco </td><td>cinq  </td></tr>
<tr><th>6 <td>six  </th><td>şase </td><td>sei    </td><td>seis  </td><td>six   </td></tr>
<tr><th>7 <td>seven</th><td>şapte</td><td>sette  </td><td>siete </td><td>sept  </td></tr>
<tr><th>8 <td>eight</th><td>opt  </td><td>otto   </td><td>ocho  </td><td>huit  </td></tr>
<tr><th>9 <td>nine </th><td>nouă </td><td>nove   </td><td>nueve </td><td>neuf  </td></tr>
<tr><th>10<td>ten  </th><td>zece </td><td>dieci  </td><td>diez  </td><td>dix   </td></tr>
</table>

<h4>Large Numbers</h4>

<p>For large numbers we use addition. We separate group of 3 large numbers using a dot or a comma separator. This is tricky business because Europeans are using dot separator Americans are using comma separator.</p>

<ul>
<li>European number: 24.220.421 = 24000000 + 220000 + 421</li>
<li>American number: 24,220,421 = 24000000 + 220000 + 421</li>
</ul>

<div class="alert alert-danger">First digit in a large number can not be 0. First zeros are not significant. Therefore number 024.220.421 is not a correct decimal number.</div>

<h4>Small Numbers</h4>

<p>For small numbers we use decimals. These are numbers that follow "." (dot) - but this is American notation. In Europe we use "," (comma) to create small numbers. So now you can be totally confused because we are so divided even if we all live on the same planet.</p>

<ul>
<li>European small number: 0,22</li>
<li>American small number: 0.22</li>
</ul>

<div class="alert alert-danger">Last digit in a small number can not be 0. Last zeros are not significant. Therefore number 0.220 is not a correct decimal number.</div>


<h4>Scientific Notation</h4>

<p>We are using multiplication of a small number "m" between (0..1) with 10 at power of "n" (m × 10ⁿ). This notation is used to display very large numbers in scientific papers. Some examples of large numbers:</p>

<ul>
<li>European large number: 1,22 × 10¹² = 1.220.000.000.000</li>
<li>American large number: 1.22 × 10¹² = 1,220,000,000,000</li>
</ul>

<h4>Engineering Notation</h4>

<p>We are using multiplication of any number "m" with 10 at power of "n" (m × 10ⁿ). This notation is used to display very large numbers in scientific papers. Some examples of large numbers:</p>

<ul>
<li>European large number: 12,12 × 10¹² = 12,120,000,000,000</li>
<li>American large number: 12.12 × 10¹² = 12.120.000.000.000</li>
</ul>

<h4>Exponential Notation</h4>

<p>We are using "E" notation in Computer Science because we are using ASCII symbols and there is no support for superscript. So we use letter "e" and "E" to express power of 10 without explicit using number 10. This notation looks like: "###E##" or "###e##" where "#" is a digit. Fractions are using negative exponent: "###E-##".</p>

<ul>
<li>Earth mass: 5.9724E24 = 5972400000000000000000000 kg.</li>
<li>An inch is: 2.54E1 mm  = 25.4 mm</li>
</ul>

<h3>Roman System</h3>

<p>Believe or not but Romans ware very bad at mathematics. They knew how to count only up to 5000, using sticks. They do not have a representation for Null. So this numeric system is actually not used in Computer Science.</p>

<p>In this system, numbers are represented using sticks. It is very fun to make a program that convert an decimal number into a Roman number. Later, we will use this exercise to learn programming languages. Here are some of Roman numbers:</p>

<h4>Symbols used:</h4>

<table class="table table-sm table-dark table-bordered">
<tr><td>1</td><td>5</td><td>10</td><td>50</td><td>100</td><td>500</td><td>1000</td></tr>
<tr><td>I</td><td>V</td><td>X </td><td>L </td><td>C  </td><td>D  </td><td>M   </td></tr>
</table>

<h4>Count to 10:</h4>

<table class="table table-sm table-dark table-bordered">
<tr><td>I  </td><td>II </td><td>III </td><td>IV </td><td>V</td>
    <td>VI </td><td>VII</td><td>VIII</td><td>IX </td><td>X</td></tr>
<tr><td>1  </td><td>2  </td><td>3   </td><td>4  </td><td>5  </td>
    <td>6  </td><td>7  </td><td>8   </td><td>9  </td><td>10 </td></tr>
</table>

<p>To create numbers you can use additions or subtraction. Therefore you can create correct and incorrect numbers. Sometimes this can be very difficult so you need a lot of practice to read large Roman numbers.</p>

<p>Numerals can be added together to form new numbers (e.g., III = I + I + I = 3), but no more than three of the same numeral can be added together.</p>

<p>In addition, to form any numbers ending with 4 or 9 or the numbers 40, 90, 400, and 900, you must subtract from the larger unit because you cannot add more than three of the same numeral. For example, IV = V − I = 5 − 1 = 4.</p>

<table class="table table-sm table-bordered">
<tbody>
<tr>
<th>Correct:(Using Subtraction)</th>
<th>Incorrect:(Using Addition) </th>
<th>Decimal</th>
</tr>
<tr><td>IV</td><td>IIII  </td><td>4  </td></tr>
<tr><td>IX</td><td>VIIII </td><td>9  </td></tr>
<tr><td>XL</td><td>XXXX  </td><td>40 </td></tr>
<tr><td>XC</td><td>LXXXX </td><td>90 </td></tr>
<tr><td>CD</td><td>CCCC  </td><td>400</td></tr>
<tr><td>CM</td><td>DCCCC </td><td>900</td></tr>
</tbody>
</table>

<h3>Binary System</h3>

<p>A single storage unit is called bit. It can store exclusive: 0 or 1. Using multiple storage units grouped together we can store combinations of 0 and 1. For example on two bit we can represent 4 combinations: {00, 01, 10, 11}. This is called "binary" system. It has two digits: {0,1}.</p>

<h4>Counting from 1 to 10</h4>

<p>It takes 4 bits to be able to count from 0 to 10. This is one of the reason computers have memory organized in multiple of 4. Now let's learn how to count using binary:</p>

<ul>
<li>0000 = 0</li>
<li>0001 = 1</li>
<li>0010 = 2</li>
<li>0011 = 3</li>
<li>0100 = 4</li>
<li>0101 = 5</li>
<li>0110 = 6</li>
<li>0111 = 7</li>
<li>1000 = 8</li>
<li>1001 = 9</li>
<li>1010 = 10</li>
</ul>

<h3>Octal System</h3>

<p>If we pair up 3 bits we can represent more digits: {0,1,2,3,4,5,6,7} this kind of representation is called "octal" system, and is very rarely used.</p>

<h3>Hexadecimal System</h3>

<p>We can use 4 bits and increase the number of combinations to 16 digits: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ,A ,B ,C ,D ,E ,F}. The first {0001 = 1} the last {1111 = F}. This representation is called "hexadecimal". One hexadecimal digit occupy 4 bits, so it matches very well with binary system.</p>

<p>As you can see there is not an exact match between the number of possible combinations and 10 digits. Therefore we have invented new digits: {A, B, C, D, E, F} sometimes these digits are represented using lowercase characters: { a, b, c, d, e, f }.</p>

<h4>Memory Addresses</h4>

<p>Computer science is using groups of 8 bits to represent memory addresses between (0..255) &equiv; (00..FF). This is called "1 byte"= 8 bit.</p>

<p>Two bytes used to represent a "1 word" = 16 bit  &equiv; (0000..FFFF). On 16 bit we can represent  2¹⁶ = 65536 addresses that is numbers from 0 to 65,535.

<h4>Memory Capacity</h4>

<p>In computer science we measure memory using Bytes (B), Kilo Bytes (KB) and Mega Bytes (MB), then Giga Bytes (GB) and Tera Bytes (TB) and Penta Bytes (PB) and Exa Bytes (EB).

<ol>
<li>1 B  = 1 Byte = 8 bit </li>
<li>1 KB = 1024 B </li>
<li>1 MB = 1024 KB</li>
<li>1 GB = 1024 MB</li>
<li>1 TB = 1024 GB</li>
</ol>

<p>On 32 bit we can represent 2³² =  4294967296 addresses.  That is numbers from 0 to 4,294,967,295. Therefore operating systems on 32 bits have a limited memory capacity less than 4 GB of RAM.</p>

<p>On 64 bit we can represent 2⁶⁴ = 8,446,744,073,709,551,616 bytes. This is a very large number representing 16 exabytes RAM capacity. Of course in practical applications, the maximum numbers is much lower, for example AMD64 standard allows 256 TB of RAM. </p>


<h3>Endian Encoding</h3>

<p>Internal representation of numbers and symbols is different depending on the computer type, operating system and device. For now is suffice to know that "PC" encoding for example is different than "MAC" encoding.</p>

<p>In computing, endianness is the order or sequence of bytes of a word of digital data in computer memory. Endianness is primarily expressed as big-endian (BE) or little-endian (LE). </p>

<p><b>BE:&nbsp;</b>A big-endian system stores the most significant byte of a word at the smallest memory address and the least significant byte at the largest. </p>

<p><b>LE:&nbsp</b>A little-endian system, in contrast, stores the least-significant byte at the smallest address.</p>

<p>Endianness may also be used to describe the order in which the bits are transmitted over a communication channel, e.g., big-endian in a communications channel transmits the most significant bits first.</p>

<h2><a id="identifiers"/>Identifiers</h2>

<p>When you create a program, you give names to program elements. These names are symbolic representations for data elements, structures, group of statements or sub-programs. You need a name so you can refer to data elements more easily, without repeating the data symbols themselves.</p>

<h4>Example:</h4>
<p>In this example we define a vector "v" using a Python single dimension list and then check if an element is member of this list. "v" and "x" are both identifiers.</p>

<pre><code class="language-python">v = [1,4,6,12,32]
x = input("check this number")
if x in v:
 print("found")
else:
 print("not found")
</code></pre>

<h4>Sigil:</h4>

<p>Sometimes a language uses some kind of prefix for variable names. This is called "sigil" and has the purpose to differentiate identifiers by purpose. For example in Ruby, the global variables use sigil "$". That means all variables that start with "$" will be global variables while sigil "@" represent an object attribute.</p>

<p>In PHP all variables start with "$", global or not global. Some developers find this rule annoying. In my languages Bee and EVE I use sigil "$" for global system constants and "@" for global system variables.</p>

<h2><a id="types"/>Type systems</h2>

<p>Programming languages must deal with data. To do this, data is classified by category. For each category there are rules of representation and manipulation. This classification and the rules are called in computer science: "type system".</p>

<h4>Immutable Data</h4>
<p>Data can be embedded into the program itself or it can be external. When embedded in the program, data is immutable. That means it is constant. You can change this kind of data only if you change the program.</p>

<h4>Mutable Data</h4>

<p>External data is usually mutable. If is stored on a device that has R/W (Read &amp; Write) capability like HDD (Hard Disk), or RW-CD (Read Write &ndash; Compact Disk). Sometimes a device can store external data in read only mode. For example optical disk or ROM (Read Only Memory) can store data that becomes immutable.</p>

<h4>Variables</h4>

<p>A variable represents data stored in RAM (Random Access Memory). We can alter value of this kind of data very easy, many times without wearing off the storage. In low level computation data is stored as bit: "0" or "1", but a high level language you can store and manipulate abstract data types, for example: "numeric", "string", "boolean", "date", "time".</p>

<h4>Measurement Units</h4>

<p>Most computer languages do not have notion of measurement units. So a number can represent any kind of physical or abstract concept. For example: width, height, weight. Only "date" and "time" have measurement units. Computer scientists believe that a computer language becomes too complex if is dealing with measurement units.</p>

<h3>Static typing</h3>

<p>In Computer Science we say a programming language is using "static typing" when the data type for a variable or a parameter must be defined in the same time with the variable and can not be changed during run-time. You can of course change the declaration in source code and then a variable will have a new type but this is a permanent change.</p>

<h3>Dynamic typing</h3>

<p>In Computer Science we say a programming language is using "dynamic typing" when the data type for a variable or a parameter is not defined and can be changed. This do not means a variable do not have a type. It means the type can change when you change the value dynamically at run-time.</p>

<h2><a id="literals"/>Data Literals</h2>

<p>Data literals are symbols or group of symbols that represent constant data. For example: 100 represent the number 100 written in decimal. There are numerous other notations for numbers, representing different data types.</p>

<p>A group of multiple data elements like a list or a data set can have a special literal created with alphanumeric symbols, delimiters and separators. Once you have learned these conventions, most languages will be easier to grasp since all are using same conventions.</p>
<table class="table table-striped table-bordered">
<thead>
<tr>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>'a'</td>
<td>Single quoted string</td>
</tr>
<tr>
<td>"string"</td>
<td>Double quoted string</td>
</tr>
<tr>
<td>0b10110</td>
<td>Binary number</td>
</tr>
<tr>
<td>1234</td>
<td>Integer number</td>
</tr>
<tr>
<td>OxFFFF</td>
<td>Hexadecimal number</td>
</tr>
<tr>
<td>U+FFFF</td>
<td>Unicode code-point</td>
</tr>
<tr>
<td>0.05</td>
<td>Decimal number</td>
</tr>
<tr>
<td>1E10</td>
<td>Scientific notation float numbers</td>
</tr>
</tbody>
</table>

<h2><a id="expressions"/>Expressions</h2>

<p>You should be familiar with this concept from mathematics. In computer science there are 3 kind of expressions: Infix, Postfix and Prefix. It is easiest to demonstrate the differences by looking at examples of operators that take two operands:</p>

<h3>Expressions types:</h3>

<pre><code class="language-python">+ x y : Prefix
x + y : Infix
x y + : Postfix
</code></pre>
<p>In these expressions x, y are operands while "+" is an operator. The most simple expressions are using one single operator and one operand. For example "-4" is an expression while "4" is not an expression but a single constant literal. "2 + 4" however is an expression even if there is no variable involved.</p>
<p>Expressions can be combined in larger expressions using operators. Order of execution can be controlled using operator precedence and also round parenthesis (x+y). We will investigate this in our next examples:</p>

<h3>Infix Expressions:</h3>
<pre><code class="language-python">x+y+z
a + b / 2 + c * 2
(a + b) / (a * b)
x &ne; y
a &le; 5
</code></pre>

<p>Most computer languages are using infix expressions. You will learn details about literals and expressions in next course: CSP: Programming. Usually we describe literals and expressions as basic language concepts in first or second tutorial article about every computer language.</p>


<h2><a id="languages"/>Programming languages</h2>

<div class="alert alert-secondary shadow-sm">Programming languages are written artificial languages created for humans to describe and resolve problems. A computer can read these languages and can convert them into executable instructions. In general, artificial languages are much more simpler than spoken languages but more precise.</div>

<p>Computer programs are created using a programming language. In computer industry there are many programming languages available, with different styles of programming, called programming paradigms.</p>

<p>The programming languages and computer languages are considered synonyms. However I think a computer language signify languages more close to the machine while programming language signify more abstract higher generation languages.</p>
<p><b>Example:</b> Believe it or not this is a complete program written in Python ...</p>
<div>

<pre><code class="language-python"># compute factorial of n
def factorial(n):
    if n==0:
        return 1
    else:
        return n*factorial(n-1)
# call factorial function and capture result
result=factorial(5)
print(result)</code></pre>
</div>

<h3><a id="classification"/>Language classification</h3>

<p>Computer languages can be categorized by the complexity:</p>
<p><b>A: Close to machines</b></p>
<ul>
<li>1GL &ndash; First Generation:</li>
<li>2GL &ndash; Second Generation</li>
</ul>
<p><b>B: Close to humans</b></p>
<ul>
<li>3GL &ndash; Third Generation Language</li>
<li>4GL &ndash; Forth Generation Language</li>
<li>5GL &ndash; Fifth Generation Language</li>
</ul>
<h4>Examples:</h4>
<ul>
<li>Machine code is 1'st generation language;</li>
<li>Assembly is 2'nd generation language;</li>
<li>C is 3'rd generation language;</li>
<li>Java is 3'rd generation language;</li>
<li>SQL is a 4'th generation language;</li>
<li>Haskell is a 4'th generation language;</li>
</ul>

<h3><a id="paradigms"/>Programming Paradigms</h3>

<p>Computer languages can be classified also by programming paradigm. This is a way of thinking about programming. It represents semantic rules of a language, that you must learn before you can read or write code. These are the programming paradigms that are used in diverse languages:</p>
<ul>
<li>Linear programming,</li>
<li>Structured programming,</li>
<li>Procedural programming,</li>
<li>Imperative programming,</li>
<li>Declarative programming,</li>
<li>Object oriented programming,</li>
<li>Aspect oriented programming,</li>
<li>Functional programming,</li>
<li>Logic programming.</li>
</ul>

<div class="alert alert-info">Some computer languages are pure and implement a single paradigm and others are hybrid and implement multiple paradigms. In my opinion, multi-paradigm languages are superior but more difficult to learn. Pure languages are more easy to implement but due to many restrictions, harder to use.</div>

<h4>Examples:</h4>
<ol>
<li>FORTRAN is a pure structured language,</li>
<li>Algol is a pure procedural language,</li>
<li>Python is multi-paradigm language,</li>
<li>Ruby is a pure Object Oriented language,</li>
<li>Lisp is first functional language,</li>
<li>Haskel is pure functional language,</li>
<li>SQL is pure declarative language,</li>
<li>Prolog is pure logical programming language.</li>
</ol>


<h3>Learning a programming language</h3>

<p>Making software applications implicit requires you to learn a computer language. Before you do you must understand this is not an easy task and it will require significant effort. To learn a computer language you have to learn 3 things:</p>
<ul>
<li>Logic &ndash; the reasoning process to resolve problems;</li>
<li>Syntax &ndash; the words and rules of the language;</li>
<li>Semantic &ndash; the way we create statements. </li>
</ul>

<hr/>

<h2><a id="logic"/>Logic Science</h2>

<div class="alert alert-secondary shadow-sm">
<p>The logic was discovered by Greeks and formalized by Aristotle. Logic means thought or reason. Initially the logic was described only by philosophy. However in time a new mathematical branch was developed. Logic is the science of truth. The purpose of logic is wisdom.</p>
</div>


<h3>Logical Inference</h3>

<div class="alert alert-info shadow-sm"><span style="color:brown">Logical inference:&nbsp;</span>Using valid arguments into a sentence we can derive a logical conclusion. Sound arguments will produce the same conclusion no matter who makes the arguments or who derive the conclusion.</div>

<p>Logical inference is the most important concept in logic. It is also known as  <em>deduction</em> or <em>implication</em>. This is a conclusion we reach after we study the arguments or premises into a sentence. Inference is a way of thinking and reasoning.</p>

<p>The inference and reason do not work the same in all cultures. For example a Christian will not reach the same conclusion from a religious sentence as another person that is Buddhist or Muslim. The words may be interpreted in different ways and lead to different conclusions.</p>

<p><b>Sentences can be classified in three categories:</b></p>
<ul>
<li>Imperative sentences</li>
<li>Interrogative sentences</li>
<li>Declarative sentences</li>
</ul>

<p>It is important to know that logic can't create good inference from imperative or interrogative sentences but only from declarative sentences. Imperative sentence is also a command from a superior entity or authority like Emperor, Queen, Fuhrer, President or God.</p>

<div class="alert alert-danger shadow-sm"><span style="color:brown">Info:&nbsp;</span>By making inference from imperative sentences one culture can fall into irrational believes, wrong lows and social injustice. Logic can only work based on facts and solid arguments not on irrational commands.</div>

<h4>Fundamental logic rules and principles:</h4>

<p>Let's say we have an argument or a premise and a sentence. Following are some logic rules that can apply to these two:</p>
<ul>
<li><b>Identity rule:</b>&nbsp;An argument is identical with itself and not something else;</li>
<li><b>Contradiction rule:</b>&nbsp;An argument cannot be true and false in same sentence;</li>
<li><b>Validity rule:</b>&nbsp;An argument is valid if the truth of premises lead to truth of the conclusion.</li>
</ul>

<h3>Validity and Soundness</h3>

<div class="alert alert-secondary shadow-sm">A deductive argument is said to be valid if takes a form that makes it impossible for the premises to be true and the conclusion nevertheless to be false. Otherwise, a deductive argument is said to be invalid.</div>
<p>A deductive argument is sound if and only if it is both valid, and all of its premises are true. Otherwise, a deductive argument is unsound. Unsound arguments are invalid.</p>

<h3>Propositional Logic</h3>

<div class="alert alert-secondary shadow-sm">The propositional logic study the relation between arguments and sentences. Deductive arguments can be propositions or sentences that can have Boolean values: True or False. This logic do not deal with the content of propositions but only with the relation between propositions.</div>
<p>In this rules we use A and B and P to represent logical propositions. Part of propositional logic are relations: IS, AND, OR, NOT. This relations have very precise rules that makes propositional logic a reliable theory.</p>

<p><b>Fundamental rules:</b></p>

<p>There are several Logical rules that are universal and can't be broken. Nobody can contradict them in any culture or language. If you understand propositional logic rules you have done your first step toward understanding computer science.</p>

<ul>
<li>If A and B are true then P = A and B is true.</li>
<li>If A and B are false then P = A and B is false.</li>
<li>If A or B is false then P = A and B is false.</li>
<li>If A or B is true then P = A or B is true.</li>
<li>If A is true then P = not A is false.</li>
<li>If B is false then P = not B is true.</li>
</ul>

<p>In addition operators "or" "and" are commutative. That means:</p>

<ul>
<li>A and B == B and A</li>
<li>A or  B == B or  A</li>
</ul>

<p><b>Morgan's laws:</b></p>

<p>Sometimes you can transform one logical expression into another equivalent expression without knowing the value of the arguments. These rules are very useful in Computer Science to optimize Boolean expressions.</p>

<ul>
<li>the negation of a disjunction is the conjunction of the negations;</li>
<li>the negation of a conjunction is the disjunction of the negations;</li>
</ul>

<p>Let's explain what it means in terms of expressions:</p>

<ul>
<li>not ( not A)  == A </li>
<li>not (A or B)  == (not A) and (not B)</li>
<li>not (A and B) == (not A) or  (not B)</li>
</ul>


<h3>Boolean algebra</h3>

<p>Boolean algebra is the branch of algebra in which the values of the variables are the truth values true and false, usually denoted 1 and 0 respectively. This contrasts with general algebra that study other numbers not only the value 1 and 0.</p>

<p><b>Logical Operations:</b></p>
<p>I have found these are the most suitable symbols for logical operators. Though no programming language yet uses them.</p>
<table class="table table-striped table-bordered">
<thead>
<tr>
<th>symbol</th>
<th>alternative</th>
<th>meaning</th>
<th>notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>&not;</td>
<td>!</td>
<td>NOT</td>
<td>negation</td>
</tr>
<tr>
<td>&and;</td>
<td>&amp;</td>
<td>AND</td>
<td>conjunction</td>
</tr>
<tr>
<td>&or;</td>
<td>|</td>
<td>OR</td>
<td>disjunction</td>
</tr>
<tr>
<td>&oplus;</td>
<td>^</td>
<td>XOR</td>
<td>exclusive disjunction</td>
</tr>
<tr>
<td>&darr;</td>
<td>&nbsp;</td>
<td>NOR</td>
<td>p &darr; q = &not; (p &or; q)</td>
</tr>
<tr>
<td>&uarr;</td>
<td>&nbsp;</td>
<td>NAND</td>
<td>p &uarr; q = &not; (p &and; q)</td>
</tr>
</tbody>
</table>

<h4>The table of truth:</h4>

<p>Next table shows all possible combinations and the result for logical operators.</p>
<table class="table table-striped table-bordered">
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>&not; p</th>
<th>&not; q</th>
<th>p &oplus; q</th>
<th>p &and; q</th>
<th>p &or; q</th>
</tr>
</thead>
<tbody>
<tr>
<th>1</th>
<th>1</th>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<th>1</th>
<th>0</th>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<th>0</th>
<th>1</th>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<th>0</th>
<th>0</th>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>

<h3>Predicate logic</h3>

<div class="alert alert-secondary shadow-sm">Predicate logic study the things that are considered predicates and relations between the things. This is much more useful and powerful then the propositional logic. The things can be represented using data and values that can be connected with relational operators and symbols.</div>

<p>For example we can study numbers and relation between numbers using predicate logic. A number can be greater, equal or less than other number. Also a number can be different or not equal to other number. In the next table we show you the most usual notation for comparison operators.</p>

<div class="table-wrapper">
<table class="table table-striped table-bordered">
<tbody>
<tr>
<th>Math</th>
<th>CS</th>
<th>Description</th>
<th>True = 1</th>
<th>False = 0</th>
</tr>
<tr>
<td>=</td>
<td>==</td>
<td>Equal</td>
<td>1 == 1&nbsp;</td>
<td>1 == 0</td>
</tr>
<tr>
<td>&ne;</td>
<td>!=</td>
<td>Not equal</td>
<td>1 != 0&nbsp;</td>
<td>1 != 1</td>
</tr>
<tr>
<td>&gt;</td>
<td>&gt;</td>
<td>Greater than</td>
<td>2 &gt; 1</td>
<td>5 &gt; 5 + 1</td>
</tr>
<tr>
<td>&lt;</td>
<td>&lt;</td>
<td>Less than</td>
<td>0 &lt; 1</td>
<td>1 &lt; 0</td>
</tr>
<tr>
<td>&ge;</td>
<td>&gt;=</td>
<td>Greater than or equal to</td>
<td>1 &gt;= 0</td>
<td>1 &gt;= 2</td>
</tr>
<tr>
<td>&le;</td>
<td>&lt;=</td>
<td>Less than or equal to</td>
<td>1 &lt;= 1</td>
<td>1 &lt;= 0</td>
</tr>
</tbody>
</table>
</div>

<h3>Lists &amp; Sets</h3>

<p>To understand the predicate logic better we need to grasp a sets and collections of things. A set is a group of things that are unique represented and not duplicated. All things in a set can be similar or can have characteristics in common. We call members of a set: <em>"elements"</em>. </p>

<div align="center">
  <img src="img/set-example.svg" alt="Set Examples"
       width="600" class="img-fluid protect rounded shadow border" >
  <p>Examples of 2 Sets</p>
</div>

<p>Sometimes we need to make a collection of elements that can be duplicated. In this case we have a "list of elements" not a sets because some of the elements are not unique. We refer in computer science to a list or a set of element by using the term: <em>collection</em>.</p>

<p>Predicate logic study the elements of collections and the relations between them. For example an element can belong to a set or do not belong to a set. Two sets can contain the same elements or different elements. Then the sets are equal or not equal.</p>

<h4>Operations</h4>

<p>Operations between sets can produce new sets or logic results. Also it is possible to make operations between one set and one value to check if the value belong to a set. In next table we use Unicode symbols for operators between sets:</p>

<table class="table table-bordered table-striped">
<thead>
<tr>
<th>symbol</th>
<th>example</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>&cap;</td>
<td>R = A &cap; B </td>
<td>Intersection between two sets  => new set</td>
</tr>
<tr>
<td>&cup;</td>
<td>R = A &cup; B</td>
<td>Union between two sets  => new set</td>
</tr>
<tr>
<td>&sub;</td>
<td>b = A &sub; B</td>
<td>Set is A included in superset B: => boolean</td>
</tr>
<tr>
<td>&sup;</td>
<td>b = A &sup; B</td>
<td>Set A contain subset B: => boolean</td>
</tr>
<tr>
<td>&Delta;</td>
<td>&Delta; = A - B</td>
<td>Set difference, => new set</td>
</tr>
<tr>
<td>&isin;</td>
<td>b = x &isin; A</td>
<td>Belong: check if element belong to collection => boolean</td>
</tr>
<tr>
<td>&equiv;</td>
<td>b = A &equiv; B</td>
<td>Equivalent: check if A has same elements as B => boolean</td>
</tr>
<tr>
<td>&forall;</td>
<td>&forall; x &isin; A </td>
<td>Any element: used in collection qualification => boolean</td>
</tr>
<tr>
<td>&exist;</td>
<td>&exist; x &isin; A</td>
<td>Exist: used in collection qualification => boolean</td>
</tr>
</table>

<h4>Intersection</h4>

<div class="alert alert-secondary">Intersection between two sets A, B will be a smaller set R that will contain all common elements of A and B. All other elements will not be included.</div>

<div align="center">
  <img src="img/set-intersect.svg" alt="Intersection"
       width="380" class="img-fluid protect rounded shadow border" >
  <p>Set Intersection</p>
</div>

<h4>Union</h4>

<div class="alert alert-secondary">Union between two sets A, B will be a larger set R that contain all elements of A and all elements of B, but duplicate elements will be included only once.</div>

<div align="center">
  <img src="img/set-union.svg" alt="Union"
       width="400" class="img-fluid protect rounded shadow border" >
  <p>Set Union</p>
</div>

<h4>Difference</h4>

<div class="alert alert-secondary">Difference between two sets A, B will be a set C that contain all elements of A but not elements that are common with B. There is a second difference D that we can make between B and A.</div>

<div align="center">
  <img src="img/set-difference.svg" alt="Difference"
       width="600" class="img-fluid protect rounded shadow border" >
  <p>Set Difference</p>
</div>

<h4>Vector &amp; Matrix</h4>

<p>In mathematics there are 2 significant numeric collections: Vectors and Matrixes. In Python we define a "List" that can have one or more dimensions and can hold a Vector or a Matrix. Some languages use term: "Array". Sometimes "Array" and "List" are different things with similar properties.</p>

<h3>Fuzzy Logic</h3>

<div class="alert alert-secondary shadow-sm">Fuzzy logic is an attempt to incorporate nature's inherent fuzziness into technology. This logic works not only with values 1=True and 0=False but we some values in between. Not everything is black or white but there is a gray area. This may be related to probabilistic values that are values between 0 and 1. Fuzzy Logic is used in neural networks and machine learning.</div>

<p>The theory of Quantum Computing is using a similar concept called <em>"Quantum Logic"</em>. This is based on quantum bits (qbits). The difference is that number of states between {0,1} in quantum computing is limited while in fuzzy logic the number of states between {0,1} are infinite.</p>


<h2><a id="machines"/>State Machines</h2>

<div class="alert alert-secondary shadow-sm">A "state machine", is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. We call this also a "Finite State Machine" FSM.</div>

<h3>Moore machines</h3>

<p>Moore machine was invented by Edward Moore in 1956 and is called Moore machine. Moore machines consist of states and transitions. States are able to produce outputs, and the output is determined solely by the current state, not by any input.</p>

<h3>Mealy machines</h3>

<p>Mealy machines were invented by George H. Mealy in 1955. In comparison with Moore machines, Mealy machines produce outputs only on transitions and not in states. This often results in state diagrams with fewer states because more logic can be put on transitions.</p>

<h3>Harel state charts</h3>

<p>A state chart is a visual formalism for complex systems. Basically Harel state charts are Mealy/Moore state machines extended by further concepts that allow us to model complex systems in a practical way.</p>

<p>David Harel did his PhD in 1978 at the Massachusetts Institute of Technology in Cambridge. He then became a Professor for Computer Science at the Weizmann Institute in Jerusalem in 1980.</p>

<blockquote class="alert alert-warning"><b>David Harel: &nbsp;</b>A complex system cannot be beneficially described in this naive fashion, because of the unmanageable, exponentially growing multitude of states, all of which have to be arranged in a flat non stratified fashion, resulting in an unstructured, unrealistic, and chaotic state diagram.</blockquote>

<h3>UML statechart</h3>

<p>UML stands for "Unified Modeling Language". UML state machines have the characteristics of both Mealy machines and Moore machines.UML state machine is an object-based variant of Harel state chart.</p>

<h3>Usability</h3>

<p>State machines are useful to analyze and theorize the computation using abstract notations. In practice there are efforts to create various code generators to translate the state charts into source code.</p>

<h3>Representation</h3>

<p>State machines can be represented in form of tables and diagrams. States are represented in diagrams by round circles, or shapes and transitions between states by arc of circles with arrow at end. A state machine diagram is usually oriented from top down or from left to right. The entry point is usually represented by a black dot. Some states are marked as "accepting" states with double line circle.</p>

<div align="center">
  <img src="img/state-machine.svg" alt="state-machine"
       width="300" class="img-fluid protect rounded shadow border" >
  <p>State Machine</p>
</div>

<h3>Turing Machine</h3>

<div class="alert alert-secondary shadow-sm">A Turing Machine was invented by Alan Turing to break the German encryption machine Enigma. Enigma code was broken using the first universal computation machine that was named later computer.</div>

<p>Today we use term: Turing Complete to classify a computer language that can do what a Turing Machine can do. Theoretical it can resolve any finite logical problem, by splitting it into simple operations. A Turing machine can be represented as a finite state machine but we show instead a conceptual diagram that is more easy to grasp:</p>


<div align="center">
  <img src="img/turing-machine.svg" alt="Turing Machine"
       width="640" class="img-fluid protect rounded shadow border" >
  <p>Turing Machine</p>
</div>


<h2><a id="inteligence"/>Artificial Intelligence</h2>

<div class="alert alert-secondary shadow-sm">Artificial intelligence is often used to describe machines (or computers) that mimic cognitive functions usually associated with the human mind, such as <em>learning</em> and <em>reasoning.</em></div>

<h3>Machine Learning</h3>

<p>We have not yet achieved <em>artificial intelligence</em> per se but we have created instead something called <em>machine learning</em> that is a fancy word for statistic. It is build on the idea that we can analyze data and predict new data by detecting a "trend". This can be potentially used to predict the future data or to recognize "patterns" therefore simulate a primitive <em>intelligence</em>.</p>

<h4>Example:</h4>

<div align="center">
  <img src="img/statistic-trend.svg" alt="Statistic Trend"
       width="600" class="img-fluid protect rounded shadow border" >
  <p>statistic chart<br>Linear Trend</p>
</div>

<h3>Neural Network</h3>

<p>Neural nets are a means of doing machine learning, in which a computer learns to perform some task by analyzing training examples. Usually, the examples have been hand-labeled in advance.</p>

<p>Most of today’s neural nets are organized into layers of nodes, and they’re <em>feed-forward</em>, meaning that data moves through them in only one direction. An individual node might be connected to several nodes, in layer from which it receives data, and several nodes in the layer to which it sends data.</p>

<div align="center">
  <img src="img/neural-network.svg" alt="Neural Network"
       width="520" class="img-fluid protect rounded shadow border" >
  <p>Neural Network <br> Conceptual Representation</p>
</div>

<p>Neural networks were first proposed in 1944 by Warren McCullough and Walter Pitts, two University of Chicago researchers who moved to MIT in 1952 as founding members of what's sometimes called the <em>first cognitive science department.</em></p>

<h4>External Resources</h4>

<ul>
   <li><a href="https://open.spotify.com/episode/2b9OgoqIsmsDXml2QYWswM?si=eh16gO4GRva-Ax7ibn737w&nd=1"
          rel = "noopener noreferrer nofollow">What is AI/ML (Podcast)</a></li>
</ul>


<hr>
<p><b>Read next:</b>
<a href="paradigms.html">Programming Paradigms</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>